<!--
Puzzle 0bb8deee Instructions:

- Set the HTML title to "0bb8deee".

- On page load, randomly generate 2 to 5 grid pairs. Each pair consists of an input grid and an output grid displayed within 30x30 pixel containers.

- For the entire puzzle:
  - Choose a background color (60% chance of black). Use this color for all grids.
  - Pick a number between 1 and 2 (numPatternColors). This determines how many additional colors (excluding the background color) are used in shape patterns.

For each input grid:

1. Randomly set grid dimensions between 11x11px and 30x30px.

2. Choose a divider color (not the background color).

3. Randomly select x and y positions for divider lines, ensuring at least 5x5px in each resulting quadrant.

4. Draw 1px divider lines at these positions.

5. Randomly choose a shape size between 3x3px and 5x5px.

6. In each quadrant:
   - Place a shape of the chosen size within the quadrant, avoiding dividers and grid edges.
   - For each shape:
     - Select numPatternColors random colors (excluding the background color), and include the background color.
     - Fill the shape with a random pixel-by-pixel pattern using these colors.
     - Ensure at least one pixel is not the background color.

For each output grid:

1. Set grid size to double the shape size in width and height.

2. In each quadrant:
   - Place the corresponding shape from the input grid.
   - Scale the shape to fill the quadrant entirely.
   - Preserve the original pixel patterns and colors.

Notes:

- Do not use canvas elements.
- Ensure the script runs without infinite loops or crashes.
- Use predefined colors for selections.

-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>0bb8deee</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        background-color: #c2c0c0;
      }
      main {
        display: block;
      }
      .pair {
        display: flex;
      }
      .container {
        position: relative;
        height: 30px;
        width: 30px;
        background-color: #c2c0c0;
        margin: 0px;
        padding: 0px;
      }
      .grid {
        position: relative;
        background-color: #111111;
        max-height: 30px;
        max-width: 30px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <main>
      <!-- Pairs will be generated by JavaScript -->
    </main>

    <script>
      const colors = [
        "#111111", // black
        "#1E93FF", // blue
        "#F93C31", // red
        "#4FCC30", // green
        "#FFDC00", // yellow
        "#E6E6E6", // grey
        "#E53AA3", // magenta
        "#FF851B", // orange
        "#87D8F1", // light blue
        "#921231", // maroon
      ];

      function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      (function () {
        // Pick numPatternColors for the whole puzzle between 1-2
        const numPatternColors = getRandomInt(1, 2);

        // Pick background color
        let availableColors = colors.slice();
        let backgroundColor;
        if (Math.random() < 0.6) {
          backgroundColor = "#111111"; // black
        } else {
          const bgIndex = getRandomInt(0, availableColors.length - 1);
          backgroundColor = availableColors.splice(bgIndex, 1)[0];
        }

        // Determine the number of pairs (between 2 and 5)
        const numPairs = getRandomInt(2, 5);

        for (let i = 1; i <= numPairs; i++) {
          createPair(i, backgroundColor, numPatternColors);
        }
      })();

      function pickDividerColor(backgroundColor) {
        const availableDividerColors = colors.filter(
          (color) => color !== backgroundColor
        );
        return availableDividerColors[
          getRandomInt(0, availableDividerColors.length - 1)
        ];
      }

      function createPair(index, backgroundColor, numPatternColors) {
        const pairDiv = document.createElement("div");
        pairDiv.classList.add("pair");

        // Create input container
        const inputContainer = document.createElement("div");
        inputContainer.classList.add("container");
        const inputGrid = document.createElement("div");
        inputGrid.classList.add("grid");
        inputGrid.id = `input-${index}`;
        inputContainer.appendChild(inputGrid);

        // Create output container
        const outputContainer = document.createElement("div");
        outputContainer.classList.add("container");
        const outputGrid = document.createElement("div");
        outputGrid.classList.add("grid");
        outputGrid.id = `output-${index}`;
        outputContainer.appendChild(outputGrid);

        // Append containers to pair
        pairDiv.appendChild(inputContainer);
        pairDiv.appendChild(outputContainer);

        // Append pair to main
        document.querySelector("main").appendChild(pairDiv);

        // Generate the input grid
        const inputShapeData = generateInputGrid(
          inputGrid,
          backgroundColor,
          numPatternColors
        );

        // Generate the output grid
        generateOutputGrid(outputGrid, backgroundColor, inputShapeData);
      }

      function generateInputGrid(
        gridElement,
        backgroundColor,
        numPatternColors
      ) {
        const width = getRandomInt(11, 24);
        const height = getRandomInt(11, 24);

        gridElement.style.width = width + "px";
        gridElement.style.height = height + "px";
        gridElement.style.backgroundColor = backgroundColor;
        gridElement.style.position = "relative";

        const dividerColor = pickDividerColor(backgroundColor);

        const xMin = 5;
        const xMax = width - 5;
        const yMin = 5;
        const yMax = height - 5;
        const xDivider = getRandomInt(xMin, xMax);
        const yDivider = getRandomInt(yMin, yMax);

        // Vertical divider
        const verticalLine = document.createElement("div");
        verticalLine.style.position = "absolute";
        verticalLine.style.left = xDivider + "px";
        verticalLine.style.top = "0px";
        verticalLine.style.width = "1px";
        verticalLine.style.height = height + "px";
        verticalLine.style.backgroundColor = dividerColor;
        gridElement.appendChild(verticalLine);

        // Horizontal divider
        const horizontalLine = document.createElement("div");
        horizontalLine.style.position = "absolute";
        horizontalLine.style.left = "0px";
        horizontalLine.style.top = yDivider + "px";
        horizontalLine.style.width = width + "px";
        horizontalLine.style.height = "1px";
        horizontalLine.style.backgroundColor = dividerColor;
        gridElement.appendChild(horizontalLine);

        const quadrants = [
          {
            xStart: 0,
            xEnd: xDivider - 1,
            yStart: 0,
            yEnd: yDivider - 1,
          },
          {
            xStart: xDivider + 1,
            xEnd: width - 1,
            yStart: 0,
            yEnd: yDivider - 1,
          },
          {
            xStart: 0,
            xEnd: xDivider - 1,
            yStart: yDivider + 1,
            yEnd: height - 1,
          },
          {
            xStart: xDivider + 1,
            xEnd: width - 1,
            yStart: yDivider + 1,
            yEnd: height - 1,
          },
        ];

        const minAvailableWidth = Math.min(
          ...quadrants.map((q) => q.xEnd - q.xStart + 1)
        );
        const minAvailableHeight = Math.min(
          ...quadrants.map((q) => q.yEnd - q.yStart + 1)
        );

        const maxShapeWidth = Math.min(5, minAvailableWidth);
        const maxShapeHeight = Math.min(5, minAvailableHeight);

        const shapeWidth = getRandomInt(3, maxShapeWidth);
        const shapeHeight = getRandomInt(3, maxShapeHeight);

        const shapesData = [];

        for (let i = 0; i < 4; i++) {
          const quadrant = quadrants[i];
          const availableWidth = quadrant.xEnd - quadrant.xStart + 1;
          const availableHeight = quadrant.yEnd - quadrant.yStart + 1;

          const xPosition =
            quadrant.xStart + getRandomInt(0, availableWidth - shapeWidth);
          const yPosition =
            quadrant.yStart + getRandomInt(0, availableHeight - shapeHeight);

          const shapeDiv = document.createElement("div");
          shapeDiv.style.position = "absolute";
          shapeDiv.style.left = xPosition + "px";
          shapeDiv.style.top = yPosition + "px";
          shapeDiv.style.width = shapeWidth + "px";
          shapeDiv.style.height = shapeHeight + "px";
          shapeDiv.style.display = "flex";
          shapeDiv.style.flexWrap = "wrap";
          shapeDiv.style.alignContent = "flex-start";

          // For each shape, pick patternColors which are numPatternColors random colors plus the background color
          let shapePatternColors = [backgroundColor];
          const availableColors = colors.filter((c) => c !== backgroundColor);
          for (let n = 0; n < numPatternColors; n++) {
            const index = getRandomInt(0, availableColors.length - 1);
            shapePatternColors.push(availableColors.splice(index, 1)[0]);
          }

          const pattern = [];

          let hasNonBackgroundPixel = false;

          for (let y = 0; y < shapeHeight; y++) {
            const row = [];
            for (let x = 0; x < shapeWidth; x++) {
              const pixelDiv = document.createElement("div");
              pixelDiv.style.width = "1px";
              pixelDiv.style.height = "1px";

              // Decide on a color for the pixel
              const pixelColor =
                shapePatternColors[
                  getRandomInt(0, shapePatternColors.length - 1)
                ];
              pixelDiv.style.backgroundColor = pixelColor;

              if (pixelColor !== backgroundColor) {
                hasNonBackgroundPixel = true;
              }

              shapeDiv.appendChild(pixelDiv);
              row.push(pixelColor);
            }
            pattern.push(row);
          }

          // Ensure that the shape has at least one non-background pixel
          if (!hasNonBackgroundPixel) {
            // Force one pixel to be non-background
            const randomY = getRandomInt(0, shapeHeight - 1);
            const randomX = getRandomInt(0, shapeWidth - 1);
            const pixelIndex = randomY * shapeWidth + randomX;
            const pixelDiv = shapeDiv.children[pixelIndex];
            const nonBackgroundColors = shapePatternColors.filter(
              (c) => c !== backgroundColor
            );
            if (nonBackgroundColors.length > 0) {
              const newColor =
                nonBackgroundColors[
                  getRandomInt(0, nonBackgroundColors.length - 1)
                ];
              pixelDiv.style.backgroundColor = newColor;
              pattern[randomY][randomX] = newColor;
            }
          }

          gridElement.appendChild(shapeDiv);

          shapesData.push({
            width: shapeWidth,
            height: shapeHeight,
            pattern: pattern,
            quadrantIndex: i,
          });
        }

        return {
          shapeWidth: shapeWidth,
          shapeHeight: shapeHeight,
          shapesData: shapesData,
        };
      }

      function generateOutputGrid(
        gridElement,
        backgroundColor,
        inputShapeData
      ) {
        const shapeWidth = inputShapeData.shapeWidth;
        const shapeHeight = inputShapeData.shapeHeight;

        const outputWidth = shapeWidth * 2;
        const outputHeight = shapeHeight * 2;

        gridElement.style.width = outputWidth + "px";
        gridElement.style.height = outputHeight + "px";
        gridElement.style.backgroundColor = backgroundColor;
        gridElement.style.position = "relative";

        const quadrants = [
          {
            xStart: 0,
            yStart: 0,
            width: shapeWidth,
            height: shapeHeight,
          },
          {
            xStart: shapeWidth,
            yStart: 0,
            width: shapeWidth,
            height: shapeHeight,
          },
          {
            xStart: 0,
            yStart: shapeHeight,
            width: shapeWidth,
            height: shapeHeight,
          },
          {
            xStart: shapeWidth,
            yStart: shapeHeight,
            width: shapeWidth,
            height: shapeHeight,
          },
        ];

        inputShapeData.shapesData.forEach((shape) => {
          const quadrant = quadrants[shape.quadrantIndex];

          const shapeDiv = document.createElement("div");
          shapeDiv.style.position = "absolute";
          shapeDiv.style.left = quadrant.xStart + "px";
          shapeDiv.style.top = quadrant.yStart + "px";
          shapeDiv.style.width = quadrant.width + "px";
          shapeDiv.style.height = quadrant.height + "px";
          shapeDiv.style.display = "flex";
          shapeDiv.style.flexWrap = "wrap";
          shapeDiv.style.alignContent = "flex-start";

          const pattern = shape.pattern;

          for (let y = 0; y < shape.height; y++) {
            for (let x = 0; x < shape.width; x++) {
              const pixelDiv = document.createElement("div");
              pixelDiv.style.width = "1px";
              pixelDiv.style.height = "1px";
              pixelDiv.style.backgroundColor = pattern[y][x];

              shapeDiv.appendChild(pixelDiv);
            }
          }

          gridElement.appendChild(shapeDiv);
        });
      }
    </script>
  </body>
</html>
