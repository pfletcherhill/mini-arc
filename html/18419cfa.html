<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>18419cfa</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        background-color: #c2c0c0;
      }
      main {
        display: block;
      }
      .pair {
        display: flex;
      }
      .container {
        position: relative;
        height: 30px;
        width: 30px;
        background-color: #c2c0c0;
        margin: 0px;
        padding: 0px;
      }
      .grid {
        position: relative;
        background-color: #111111;
        max-height: 30px;
        max-width: 30px;
        overflow: hidden;
      }
      .pixel {
        position: absolute;
        width: 1px;
        height: 1px;
      }
    </style>
  </head>
  <body>
    <main>
      <!-- Pairs will be generated by JavaScript -->
    </main>

    <script>
      const colors = [
        "#111111",
        "#1E93FF",
        "#F93C31",
        "#4FCC30",
        "#FFDC00",
        "#E6E6E6",
        "#E53AA3",
        "#FF851B",
        "#87D8F1",
        "#921231",
      ];

      function pickRandomColorExcluding(excludeColors) {
        const availableColors = colors.filter(
          (color) => !excludeColors.includes(color)
        );
        return availableColors[
          Math.floor(Math.random() * availableColors.length)
        ];
      }

      function createHalfPattern(width, height) {
        const pattern = [];
        const halfWidth = Math.floor(width / 2);
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < halfWidth; x++) {
            if (Math.random() < 0.5) {
              pattern.push({ x, y });
            }
          }
        }
        return pattern;
      }

      function drawPattern(
        container,
        pattern,
        rectWidth,
        rectHeight,
        color,
        isOutput = false
      ) {
        pattern.forEach((pixel) => {
          const pixelElement = document.createElement("div");
          pixelElement.classList.add("pixel");
          pixelElement.style.backgroundColor = color;

          let x = pixel.x + 2; // Add 2px margin
          let y = pixel.y + 2; // Add 2px margin

          if (isOutput) {
            x = rectWidth - 3 - pixel.x; // Reflect horizontally and account for margin
          }

          pixelElement.style.left = `${x}px`;
          pixelElement.style.top = `${y}px`;

          container.appendChild(pixelElement);
        });
      }

      const numPairs = Math.floor(Math.random() * 4) + 2;
      const isBlackBackground = Math.random() < 0.6;
      const backgroundColor = isBlackBackground
        ? "#111111"
        : pickRandomColorExcluding(["#111111"]);

      const main = document.querySelector("main");

      for (let i = 0; i < numPairs; i++) {
        const pairDiv = document.createElement("div");
        pairDiv.classList.add("pair");

        const inputContainer = document.createElement("div");
        inputContainer.classList.add("container");
        const inputGrid = document.createElement("div");
        inputGrid.classList.add("grid");
        inputGrid.id = `input-${i + 1}`;
        inputGrid.style.backgroundColor = backgroundColor;
        inputContainer.appendChild(inputGrid);

        const outputContainer = document.createElement("div");
        outputContainer.classList.add("container");
        const outputGrid = document.createElement("div");
        outputGrid.classList.add("grid");
        outputGrid.id = `output-${i + 1}`;
        outputGrid.style.backgroundColor = backgroundColor;
        outputContainer.appendChild(outputGrid);

        pairDiv.appendChild(inputContainer);
        pairDiv.appendChild(outputContainer);
        main.appendChild(pairDiv);

        const gridWidth = Math.floor(Math.random() * 9) + 16;
        const gridHeight = Math.floor(Math.random() * 9) + 16;

        inputGrid.style.width = outputGrid.style.width = `${gridWidth}px`;
        inputGrid.style.height = outputGrid.style.height = `${gridHeight}px`;
        inputGrid.style.marginLeft = outputGrid.style.marginLeft = `${
          (30 - gridWidth) / 2
        }px`;
        inputGrid.style.marginTop = outputGrid.style.marginTop = `${
          (30 - gridHeight) / 2
        }px`;

        const borderColor = pickRandomColorExcluding([backgroundColor]);
        const interiorColor = pickRandomColorExcluding([
          backgroundColor,
          borderColor,
        ]);

        const numRectangles = Math.floor(Math.random() * 3) + 1;
        const rectangles = [];
        const possibleWidths = [7, 9, 11];
        const possibleHeights = [8, 9, 10];

        for (let r = 0; r < numRectangles; r++) {
          let rectangle;
          let attempts = 0;
          do {
            attempts++;
            let width =
              possibleWidths[Math.floor(Math.random() * possibleWidths.length)];
            let height =
              possibleHeights[
                Math.floor(Math.random() * possibleHeights.length)
              ];
            if (Math.random() < 0.5) [width, height] = [height, width];
            if (width > gridWidth || height > gridHeight) continue;

            const maxX = gridWidth - width;
            const maxY = gridHeight - height;
            const x = Math.floor(Math.random() * (maxX + 1));
            const y = Math.floor(Math.random() * (maxY + 1));

            let overlaps = rectangles.some(
              (rect) =>
                !(
                  x + width <= rect.x ||
                  rect.x + rect.width <= x ||
                  y + height <= rect.y ||
                  rect.y + rect.height <= y
                )
            );

            if (!overlaps) {
              rectangle = { x, y, width, height };
              rectangles.push(rectangle);
              break;
            }
          } while (attempts < 100);

          if (!rectangle) {
            console.warn("Could not place rectangle without overlapping.");
            continue;
          }

          const inputRectDiv = document.createElement("div");
          inputRectDiv.style.position = "absolute";
          inputRectDiv.style.left = `${rectangle.x}px`;
          inputRectDiv.style.top = `${rectangle.y}px`;
          inputRectDiv.style.width = `${rectangle.width}px`;
          inputRectDiv.style.height = `${rectangle.height}px`;
          inputRectDiv.style.border = `1px solid ${borderColor}`;
          inputRectDiv.style.backgroundColor = "transparent";
          inputRectDiv.style.boxSizing = "border-box";
          inputRectDiv.style.overflow = "hidden";

          inputGrid.appendChild(inputRectDiv);

          const pattern = createHalfPattern(
            rectangle.width - 4,
            rectangle.height - 4
          );

          // Draw pattern in input grid (left half)
          drawPattern(
            inputRectDiv,
            pattern,
            rectangle.width,
            rectangle.height,
            interiorColor
          );

          // Create the rectangle in the output grid
          const outputRectDiv = inputRectDiv.cloneNode(true);
          outputRectDiv.innerHTML = ""; // Clear any content
          outputGrid.appendChild(outputRectDiv);

          // Draw pattern in output grid (right half, reflected)
          drawPattern(
            outputRectDiv,
            pattern,
            rectangle.width,
            rectangle.height,
            interiorColor,
            true
          );
        }
      }
    </script>
  </body>
</html>
