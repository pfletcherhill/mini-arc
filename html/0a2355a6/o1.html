<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>0a2355a6</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      main {
        display: block;
      }
      .pair {
        display: flex;
      }
      .container {
        position: relative;
        height: 30px;
        width: 30px;
        background-color: #c2c0c0;
        margin: 0px;
        padding: 0px;
      }
      .grid {
        position: relative;
        background-color: #111111;
        max-height: 30px;
        max-width: 30px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <main></main>

    <script>
      const colors = [
        "#111111", // black
        "#1E93FF", // blue
        "#F93C31", // red
        "#4FCC30", // green
        "#FFDC00", // yellow
        "#E6E6E6", // grey
        "#E53AA3", // magenta
        "#FF851B", // orange
        "#87D8F1", // light blue
        "#921231", // maroon
      ];

      // Remove black color
      let colorOptions = colors.filter((color) => color !== "#111111");

      // Pick a random border color
      let borderColorIndex = Math.floor(Math.random() * colorOptions.length);
      let borderColor = colorOptions[borderColorIndex];

      // Remove border color from options
      colorOptions.splice(borderColorIndex, 1);

      // Shuffle the remaining colors
      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          let j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      shuffle(colorOptions);

      // Map numbers 1-6 to colors
      let numberColorMapping = {};
      for (let i = 1; i <= 6; i++) {
        numberColorMapping[i] = colorOptions[i - 1];
      }

      // Pick a random number of pairs between 2 and 5
      let numPairs = Math.floor(Math.random() * 4) + 2;

      let mainElement = document.querySelector("main");

      for (let pairIndex = 0; pairIndex < numPairs; pairIndex++) {
        // Create pair div
        let pairDiv = document.createElement("div");
        pairDiv.className = "pair";

        // Create input container and grid
        let inputContainer = document.createElement("div");
        inputContainer.className = "container";

        let inputGrid = document.createElement("div");
        inputGrid.className = "grid";

        // Create output container and grid
        let outputContainer = document.createElement("div");
        outputContainer.className = "container";

        let outputGrid = document.createElement("div");
        outputGrid.className = "grid";

        // Generate grid size between 10 and 30 px
        let gridWidth = Math.floor(Math.random() * 21) + 10;
        let gridHeight = Math.floor(Math.random() * 21) + 10;

        // Set grid sizes
        inputGrid.style.width = gridWidth + "px";
        inputGrid.style.height = gridHeight + "px";

        outputGrid.style.width = gridWidth + "px";
        outputGrid.style.height = gridHeight + "px";

        // Append grids to containers
        inputContainer.appendChild(inputGrid);
        outputContainer.appendChild(outputGrid);

        // Append containers to pairDiv
        pairDiv.appendChild(inputContainer);
        pairDiv.appendChild(outputContainer);

        // Append pairDiv to main
        mainElement.appendChild(pairDiv);

        // Generate shapes
        let occupancyGrid = [];
        for (let y = 0; y < gridHeight; y++) {
          occupancyGrid[y] = [];
          for (let x = 0; x < gridWidth; x++) {
            occupancyGrid[y][x] = 0; // 0 indicates empty
          }
        }

        let shapes = [];

        let numShapes = Math.floor(Math.random() * 5) + 1; // 1 to 5 shapes

        for (let shapeIndex = 0; shapeIndex < numShapes; shapeIndex++) {
          let numRectangles = Math.floor(Math.random() * 6) + 1; // 1 to 6 rectangles

          let shapeRectangles = []; // To store rectangles of this shape

          // Place first rectangle
          let placed = false;
          let attempts = 0;
          while (!placed && attempts < 10) {
            attempts++;

            let rectWidth = Math.floor(Math.random() * 3) + 3; // 3 to 5 px
            let rectHeight = Math.floor(Math.random() * 3) + 3; // 3 to 5 px

            let x = Math.floor(Math.random() * (gridWidth - rectWidth + 1));
            let y = Math.floor(Math.random() * (gridHeight - rectHeight + 1));

            if (!checkOverlap(x, y, rectWidth, rectHeight, occupancyGrid)) {
              // Place rectangle
              shapeRectangles.push({
                x,
                y,
                width: rectWidth,
                height: rectHeight,
              });

              // Mark occupancy
              markOccupancy(x, y, rectWidth, rectHeight, occupancyGrid);

              placed = true;
            }
          }

          if (!placed) {
            // Cannot place first rectangle, skip this shape
            continue;
          }

          // Place subsequent rectangles
          for (let rectIndex = 1; rectIndex < numRectangles; rectIndex++) {
            placed = false;
            attempts = 0;
            while (!placed && attempts < 10) {
              attempts++;

              let rectWidth = Math.floor(Math.random() * 3) + 3; // 3 to 5 px
              let rectHeight = Math.floor(Math.random() * 3) + 3; // 3 to 5 px

              let existingRect =
                shapeRectangles[
                  Math.floor(Math.random() * shapeRectangles.length)
                ];

              let sides = ["left", "right", "top", "bottom"];
              let side = sides[Math.floor(Math.random() * sides.length)];

              let x, y;

              if (side === "left") {
                x = existingRect.x + 1 - rectWidth;

                let minY = existingRect.y - rectHeight + 1;
                let maxY = existingRect.y + existingRect.height - 1;

                minY = Math.max(0, minY);
                maxY = Math.min(gridHeight - rectHeight, maxY);

                if (maxY < minY) continue;

                y = Math.floor(Math.random() * (maxY - minY + 1)) + minY;
              } else if (side === "right") {
                x = existingRect.x + existingRect.width - 1;

                let minY = existingRect.y - rectHeight + 1;
                let maxY = existingRect.y + existingRect.height - 1;

                minY = Math.max(0, minY);
                maxY = Math.min(gridHeight - rectHeight, maxY);

                if (maxY < minY) continue;

                y = Math.floor(Math.random() * (maxY - minY + 1)) + minY;
              } else if (side === "top") {
                y = existingRect.y + 1 - rectHeight;

                let minX = existingRect.x - rectWidth + 1;
                let maxX = existingRect.x + existingRect.width - 1;

                minX = Math.max(0, minX);
                maxX = Math.min(gridWidth - rectWidth, maxX);

                if (maxX < minX) continue;

                x = Math.floor(Math.random() * (maxX - minX + 1)) + minX;
              } else if (side === "bottom") {
                y = existingRect.y + existingRect.height - 1;

                let minX = existingRect.x - rectWidth + 1;
                let maxX = existingRect.x + existingRect.width - 1;

                minX = Math.max(0, minX);
                maxX = Math.min(gridWidth - rectWidth, maxX);

                if (maxX < minX) continue;

                x = Math.floor(Math.random() * (maxX - minX + 1)) + minX;
              }

              // Check bounds
              if (
                x < 0 ||
                y < 0 ||
                x + rectWidth > gridWidth ||
                y + rectHeight > gridHeight
              ) {
                continue;
              }

              if (!checkOverlap(x, y, rectWidth, rectHeight, occupancyGrid)) {
                // Place rectangle
                shapeRectangles.push({
                  x,
                  y,
                  width: rectWidth,
                  height: rectHeight,
                });

                // Mark occupancy
                markOccupancy(x, y, rectWidth, rectHeight, occupancyGrid);

                placed = true;
              }
            }

            if (!placed) {
              // Cannot place more rectangles in this shape
              break;
            }
          }

          // Add shape to shapes array
          shapes.push(shapeRectangles);
        }

        // Now render the shapes in inputGrid and outputGrid
        shapes.forEach(function (shape) {
          // Create a color for the output grid based on the number of rectangles in the shape
          let numRects = shape.length;
          let shapeColor = numberColorMapping[numRects];

          shape.forEach(function (rect) {
            // Create rectangle div for inputGrid
            let rectDivInput = document.createElement("div");
            rectDivInput.style.position = "absolute";
            rectDivInput.style.left = rect.x + "px";
            rectDivInput.style.top = rect.y + "px";
            rectDivInput.style.width = rect.width + "px";
            rectDivInput.style.height = rect.height + "px";
            rectDivInput.style.backgroundColor = "transparent";
            rectDivInput.style.border = "1px solid " + borderColor;

            inputGrid.appendChild(rectDivInput);

            // Create rectangle div for outputGrid
            let rectDivOutput = document.createElement("div");
            rectDivOutput.style.position = "absolute";
            rectDivOutput.style.left = rect.x + "px";
            rectDivOutput.style.top = rect.y + "px";
            rectDivOutput.style.width = rect.width + "px";
            rectDivOutput.style.height = rect.height + "px";
            rectDivOutput.style.backgroundColor = "transparent";
            rectDivOutput.style.border = "1px solid " + shapeColor;

            outputGrid.appendChild(rectDivOutput);
          });
        });
      }

      function checkOverlap(x, y, width, height, occupancyGrid) {
        // Return true if any cell in the rectangle plus 1px border is occupied
        for (let i = y - 1; i <= y + height; i++) {
          for (let j = x - 1; j <= x + width; j++) {
            if (
              i >= 0 &&
              i < occupancyGrid.length &&
              j >= 0 &&
              j < occupancyGrid[0].length
            ) {
              if (occupancyGrid[i][j]) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function markOccupancy(x, y, width, height, occupancyGrid) {
        for (let i = y; i < y + height; i++) {
          for (let j = x; j < x + width; j++) {
            occupancyGrid[i][j] = 1;
          }
        }
      }
    </script>
  </body>
</html>
