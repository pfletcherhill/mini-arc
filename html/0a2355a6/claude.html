<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>0a2355a6</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      main {
        display: block;
      }
      .pair {
        display: flex;
      }
      .container {
        position: relative;
        height: 30px;
        width: 30px;
        background-color: #c2c0c0;
        margin: 0px;
        padding: 0px;
      }
      .grid {
        position: relative;
        background-color: #111111;
        max-height: 30px;
        max-width: 30px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <main id="puzzle-container">
      <!-- Pairs will be dynamically added here -->
    </main>

    <script>
      const colors = [
        "#111111", // black
        "#1E93FF", // blue
        "#F93C31", // red
        "#4FCC30", // green
        "#FFDC00", // yellow
        "#E6E6E6", // grey
        "#E53AA3", // magenta
        "#FF851B", // orange
        "#87D8F1", // light blue
        "#921231", // maroon
      ];

      // Function to get random integer between min and max (inclusive)
      function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      // Function to get random item from an array
      function getRandomItem(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      // Function to generate a random color mapping
      function generateColorMapping() {
        const availableColors = colors.filter((color) => color !== "#111111"); // Exclude black
        const borderColor = getRandomItem(availableColors);
        const remainingColors = availableColors.filter(
          (color) => color !== borderColor
        );
        const shuffledColors = remainingColors.sort(() => 0.5 - Math.random());

        const colorMapping = {
          border: borderColor,
        };

        for (let i = 1; i <= 6; i++) {
          colorMapping[i] = shuffledColors[i - 1];
        }

        return colorMapping;
      }

      // Function to create a shape
      function createShape(gridSize, borderColor) {
        const numRectangles = getRandomInt(1, 6);
        const shape = [];
        const rectSize = getRandomInt(3, 5);

        for (let i = 0; i < numRectangles; i++) {
          let newRect;
          do {
            newRect = {
              x: getRandomInt(0, gridSize - rectSize),
              y: getRandomInt(0, gridSize - rectSize),
              width: rectSize,
              height: rectSize,
            };
          } while (!isValidPlacement(shape, newRect, gridSize));

          shape.push(newRect);
        }

        return shape;
      }

      // Function to check if a new rectangle placement is valid
      function isValidPlacement(shape, newRect, gridSize) {
        for (const rect of shape) {
          if (
            newRect.x < rect.x + rect.width &&
            newRect.x + newRect.width > rect.x &&
            newRect.y < rect.y + rect.height &&
            newRect.y + newRect.height > rect.y
          ) {
            // Check if they're only overlapping by 1px
            const overlapX =
              Math.min(newRect.x + newRect.width, rect.x + rect.width) -
              Math.max(newRect.x, rect.x);
            const overlapY =
              Math.min(newRect.y + newRect.height, rect.y + rect.height) -
              Math.max(newRect.y, rect.y);

            if (overlapX !== 1 && overlapY !== 1) {
              return false;
            }
          } else if (
            Math.abs(newRect.x - rect.x) <= 1 ||
            Math.abs(newRect.y - rect.y) <= 1 ||
            Math.abs(newRect.x + newRect.width - rect.x) <= 1 ||
            Math.abs(newRect.y + newRect.height - rect.y) <= 1
          ) {
            return false;
          }
        }
        return true;
      }

      // Function to render a shape
      function renderShape(grid, shape, color) {
        shape.forEach((rect) => {
          const rectElement = document.createElement("div");
          rectElement.style.position = "absolute";
          rectElement.style.left = `${rect.x}px`;
          rectElement.style.top = `${rect.y}px`;
          rectElement.style.width = `${rect.width}px`;
          rectElement.style.height = `${rect.height}px`;
          rectElement.style.border = `1px solid ${color}`;
          rectElement.style.boxSizing = "border-box";
          grid.appendChild(rectElement);
        });
      }

      // Function to create a pair of grids
      function createPair(index, colorMapping) {
        const pair = document.createElement("div");
        pair.className = "pair";

        const gridSize = getRandomInt(10, 30);
        const shapes = [];
        const numShapes = getRandomInt(1, 5);

        for (let i = 0; i < numShapes; i++) {
          shapes.push(createShape(gridSize, colorMapping.border));
        }

        // Input grid
        const inputContainer = document.createElement("div");
        inputContainer.className = "container";
        const inputGrid = document.createElement("div");
        inputGrid.id = `input-${index}`;
        inputGrid.className = "grid";
        inputGrid.style.width = `${gridSize}px`;
        inputGrid.style.height = `${gridSize}px`;
        shapes.forEach((shape) =>
          renderShape(inputGrid, shape, colorMapping.border)
        );
        inputContainer.appendChild(inputGrid);

        // Output grid
        const outputContainer = document.createElement("div");
        outputContainer.className = "container";
        const outputGrid = document.createElement("div");
        outputGrid.id = `output-${index}`;
        outputGrid.className = "grid";
        outputGrid.style.width = `${gridSize}px`;
        outputGrid.style.height = `${gridSize}px`;
        shapes.forEach((shape) =>
          renderShape(outputGrid, shape, colorMapping[shape.length])
        );
        outputContainer.appendChild(outputGrid);

        pair.appendChild(inputContainer);
        pair.appendChild(outputContainer);

        return pair;
      }

      // Main function to generate the puzzle
      function generatePuzzle() {
        const container = document.getElementById("puzzle-container");
        const colorMapping = generateColorMapping();
        const numPairs = getRandomInt(2, 5);

        for (let i = 1; i <= numPairs; i++) {
          const pair = createPair(i, colorMapping);
          container.appendChild(pair);
        }
      }

      // Generate the puzzle when the page loads
      window.onload = generatePuzzle;
    </script>
  </body>
</html>
